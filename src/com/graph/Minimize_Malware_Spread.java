package com.graph;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Set;
import java.util.Vector;

/*
 * Nodes connected system matrix and infected nodes list, find the infected node in
 * such a way that it prevents futher spread of the virus
 *
 * Sample Input
1
3 2
1 0 1
0 1 1
1 1 1
0 2


Output
2
 * 
 */

public class Minimize_Malware_Spread {

	public static void main(String[] args) {
		int result;
		ArrayList<Integer> initial = new ArrayList<>();
		initial.add(0);
		initial.add(2);

//		1 0 1
//		0 1 1
//		1 1 1		(0) ---> (2) ---> 1  => remove 2 to stop infection
		int[][] edges = { { 1, 0, 1 }, { 0, 1, 1 }, { 1, 1, 1 } };
		List<Integer>[] graph = initGraph(edges);

		result = minMalwareSpread(graph, initial);
		System.out.println("1st case " + result); // 2

		// 0 0 1 0
		// 0 0 1 1
		// 1 1 0 0
		// 0 1 0 0		(0) --> (2) ---> 1 ---> 3  ==> remove 2
		int[][] edges2 = { { 0, 0, 1, 0 }, { 0, 0, 1, 1 }, { 1, 1, 0, 0 }, { 0, 1, 0, 0 } };
		List<Integer>[] graph2 = initGraph(edges2);
		result = minMalwareSpread(graph2, initial);
		System.out.println("2nd case " + result); // 2

		// 0 0 1 0 1
		// 0 0 1 1 0
		// 1 1 0 0 0
		// 0 1 0 0 0
		// 1 0 0 0 0

//		(0) ---> (2) ---> 1 ---> 3  ===> remove 2
//		 \
//		  \
//		   4
		int[][] edges3 = { { 0, 0, 1, 0, 1 }, { 0, 0, 1, 1, 0 }, { 1, 1, 0, 0, 0 }, { 0, 1, 0, 0, 0 },
				{ 1, 0, 0, 0, 0 } };
		List<Integer>[] graph3 = initGraph(edges3);

		result = minMalwareSpread(graph3, initial);
		System.out.println("3rd case " + result); // 2

		// 0 1 1 0 1
		// 1 0 0 0 0
		// 1 0 0 1 0
		// 0 0 1 0 0
		// 1 0 0 0 0

//		(0) ---> (2) --> 3  ===> remove 0
//		/ \
//	   1   \
//		    4
		int[][] edges4 = { { 0, 1, 1, 0, 1 }, { 1, 0, 0, 0, 0 }, { 1, 0, 0, 1, 0 }, { 0,0, 1, 0, 0 },
				{ 1, 0, 0, 0, 0 } };
		List<Integer>[] graph4 = initGraph(edges4);

		result = minMalwareSpread(graph4, initial);
		System.out.println("3rd case " + result); // 0

	}

	static List<Integer>[] initGraph(int[][] arr) {
		@SuppressWarnings("unchecked")
		List<Integer>[] graph = new ArrayList[arr.length];
		for (int a = 0; a < arr.length; a++) {
			graph[a] = new ArrayList<>();
			for (int j = 0; j < arr[a].length; j++) {
				int val = arr[a][j];
				if (a == j);
				else {
					if (val == 1)
						graph[a].add(j);
				}
			}
//			System.out.println("For vertex=" + a + " edges=" + graph[a]);
		}
		return graph;

	}

	public static int minMalwareSpread(List<Integer>[] graph, ArrayList<Integer> initial) {

		List<Integer> noninfectedNodeDepth = new ArrayList<>();
		int infectedCount = 0;
		
		Vector<Integer> v;
		for (int i = 0; i < initial.size(); i++) { // i = 0, 1
			int nonAffectedCount = 0;
//			int infectedVertex = initial.get(i);
			Set<Integer> visitedNodes = new LinkedHashSet<>();
			Queue<Integer> queue = new LinkedList<>();
			visitedNodes.add(initial.get(i)); //0 ; 2
			queue.add(initial.get(i)); // 0 ; 2
			while (!queue.isEmpty()) { //
				Integer currentNode = queue.poll(); // 2
				for (Integer node : graph[currentNode]) { // 0, 3
//					System.out.println("NonInfected="+currentNode+" node="+node);
					if (!initial.contains(node) && !visitedNodes.contains(node)) { // 3
						visitedNodes.add(node); // 3
						queue.add(node); //3
						nonAffectedCount++; // 1
					}
				}
			}

			if (nonAffectedCount > infectedCount) { // 2 > 0
				infectedCount = nonAffectedCount; // 2
				noninfectedNodeDepth.add(initial.get(i)); // (0)
			}
		}

		return noninfectedNodeDepth.get(noninfectedNodeDepth.size() - 1);
	}

}

//int localInfectedCount = 0;
//if (initial.contains(i)) {
//	
//	for (Integer no : graph[i]) {
//		if(!initial.contains(no)) {
//			localInfectedCount++;
////			System.out.println("vertex infected i="+i+" notInfected="+no);
//		}
//			
//	}
//}