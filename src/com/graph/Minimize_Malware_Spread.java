package com.graph;

import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Set;
import java.util.Vector;

/*
 * 
 * Sample Input
1
3 2
1 0 1
0 1 1
1 1 1
0 2


Output
2
 * 
 */

public class Minimize_Malware_Spread {

	public static void main(String[] args) {
//		System.out.println("Input total Graphs and the matrix size and the infected node size, then loop of matrix elements");
//		Scanner sc = new Scanner(System.in);
//        int T = sc.nextInt();
//        for(int j=0; j<T; j++){
//           String st = sc.next();
//           String[] stArr = st.split(" ");
//           int numArr[] = new int[stArr.length]; 
//           for(int i = 0;i<stArr.length;i++) {
//        	   numArr[i]=Integer.parseInt(stArr[i]);
//        	   for(int k=0; k<numArr[i];k++) {
//        		   
//        	   }
//           }
//           
//
//        }
		int result;
		ArrayList<Integer> initial = new ArrayList<>();
		initial.add(0);
		initial.add(2);

//		1 0 1
//		0 1 1
//		1 1 1
		int[][] edges = { { 1, 0, 1 }, { 0, 1, 1 }, { 1, 1, 1 } };
		List<Integer>[] graph = initGraph(edges);

//		result = minMalwareSpread(graph, initial);
//		System.out.println("1st case " + result); // 2

		// 0 0 1 0
		// 0 0 1 1
		// 1 1 0 0
		// 0 1 0 0
		int[][] edges2 = { { 0, 0, 1, 0 }, { 0, 0, 1, 1 }, { 1, 1, 0, 0 }, { 0, 1, 0, 0 } };
		List<Integer>[] graph2 = initGraph(edges2);
//		result = minMalwareSpread(graph2, initial);
//		System.out.println("2nd case " + result); // 2

		// 0 0 1 0 1
		// 0 0 1 1 0
		// 1 1 0 0 0
		// 0 1 0 0 0
		// 1 0 0 0 0
		int[][] edges3 = { { 0, 0, 1, 0, 1 }, { 0, 0, 1, 1, 0 }, { 1, 1, 0, 0, 0 }, { 0, 1, 0, 0, 0 },
				{ 1, 0, 0, 0, 0 } };
		List<Integer>[] graph3 = initGraph(edges3);

//		result = minMalwareSpread(graph3, initial);
//		System.out.println("3rd case " + result); // 2
	}

	static List<Integer>[] initGraph(int[][] arr) {
		@SuppressWarnings("unchecked")
		List<Integer>[] graph = new ArrayList[arr.length];
		for (int a = 0; a < arr.length; a++) {
			graph[a] = new ArrayList<>();
			for (int j = 0; j < arr[a].length; j++) {
				int val = arr[a][j];
				if (a == j);
				else {
					if (val == 1)
						graph[a].add(j);
				}
			}
//			System.out.println("For vertex=" + a + " edges=" + graph[a]);
		}
		return graph;

	}

	public static int minMalwareSpread(List<Integer>[] graph, ArrayList<Integer> initial) {

		List<Integer> noninfectedNodeDepth = new ArrayList<>();
		int infectedCount = 0;
		
		Vector<Integer> v;
		for (int i = 0; i < initial.size(); i++) {
			int nonAffectedCount = 0;
//			int infectedVertex = initial.get(i);
			Set<Integer> visitedNodes = new LinkedHashSet<>();
			Queue<Integer> queue = new LinkedList<>();
			visitedNodes.add(initial.get(i));
			queue.add(initial.get(i));
			while (!queue.isEmpty()) {
				Integer currentNode = queue.poll();
				for (Integer node : graph[currentNode]) {
//					System.out.println("NonInfected="+currentNode+" node="+node);
					if (!initial.contains(node) && !visitedNodes.contains(node)) {
						visitedNodes.add(node);
						queue.add(node);
						nonAffectedCount++;
					}
				}
			}

			if (nonAffectedCount > infectedCount) {
				infectedCount = nonAffectedCount;
				noninfectedNodeDepth.add(initial.get(i));
			}
		}

		return noninfectedNodeDepth.get(noninfectedNodeDepth.size() - 1);
	}

}

//int localInfectedCount = 0;
//if (initial.contains(i)) {
//	
//	for (Integer no : graph[i]) {
//		if(!initial.contains(no)) {
//			localInfectedCount++;
////			System.out.println("vertex infected i="+i+" notInfected="+no);
//		}
//			
//	}
//}